/* interact.js 1.10.19 | https://interactjs.io/license */
!function (t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).interact = t() }((function () { var t = {}; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0, t.default = function (t) { return !(!t || !t.Window) && t instanceof t.Window }; var e = {}; Object.defineProperty(e, "__esModule", { value: !0 }), e.getWindow = function (e) { return (0, t.default)(e) ? e : (e.ownerDocument || e).defaultView || r.window }, e.init = o, e.window = e.realWindow = void 0; var n = void 0; e.realWindow = n; var r = void 0; function o(t) { e.realWindow = n = t; var o = t.document.createTextNode(""); o.ownerDocument !== t.document && "function" == typeof t.wrap && t.wrap(o) === o && (t = t.wrap(t)), e.window = r = t } e.window = r, "undefined" != typeof window && window && o(window); var i = {}; function a(t) { return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, a(t) } Object.defineProperty(i, "__esModule", { value: !0 }), i.default = void 0; var s = function (t) { return !!t && "object" === a(t) }, l = function (t) { return "function" == typeof t }, u = { window: function (n) { return n === e.window || (0, t.default)(n) }, docFrag: function (t) { return s(t) && 11 === t.nodeType }, object: s, func: l, number: function (t) { return "number" == typeof t }, bool: function (t) { return "boolean" == typeof t }, string: function (t) { return "string" == typeof t }, element: function (t) { if (!t || "object" !== a(t)) return !1; var n = e.getWindow(t) || e.window; return /object|function/.test("undefined" == typeof Element ? "undefined" : a(Element)) ? t instanceof Element || t instanceof n.Element : 1 === t.nodeType && "string" == typeof t.nodeName }, plainObject: function (t) { return s(t) && !!t.constructor && /function Object\b/.test(t.constructor.toString()) }, array: function (t) { return s(t) && void 0 !== t.length && l(t.splice) } }; i.default = u; var c = {}; function f(t) { var e = t.interaction; if ("drag" === e.prepared.name) { var n = e.prepared.axis; "x" === n ? (e.coords.cur.page.y = e.coords.start.page.y, e.coords.cur.client.y = e.coords.start.client.y, e.coords.velocity.client.y = 0, e.coords.velocity.page.y = 0) : "y" === n && (e.coords.cur.page.x = e.coords.start.page.x, e.coords.cur.client.x = e.coords.start.client.x, e.coords.velocity.client.x = 0, e.coords.velocity.page.x = 0) } } function d(t) { var e = t.iEvent, n = t.interaction; if ("drag" === n.prepared.name) { var r = n.prepared.axis; if ("x" === r || "y" === r) { var o = "x" === r ? "y" : "x"; e.page[o] = n.coords.start.page[o], e.client[o] = n.coords.start.client[o], e.delta[o] = 0 } } } Object.defineProperty(c, "__esModule", { value: !0 }), c.default = void 0; var p = { id: "actions/drag", install: function (t) { var e = t.actions, n = t.Interactable, r = t.defaults; n.prototype.draggable = p.draggable, e.map.drag = p, e.methodDict.drag = "draggable", r.actions.drag = p.defaults }, listeners: { "interactions:before-action-move": f, "interactions:action-resume": f, "interactions:action-move": d, "auto-start:check": function (t) { var e = t.interaction, n = t.interactable, r = t.buttons, o = n.options.drag; if (o && o.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (r & n.options.drag.mouseButtons))) return t.action = { name: "drag", axis: "start" === o.lockAxis ? o.startAxis : o.lockAxis }, !1 } }, draggable: function (t) { return i.default.object(t) ? (this.options.drag.enabled = !1 !== t.enabled, this.setPerAction("drag", t), this.setOnEvents("drag", t), /^(xy|x|y|start)$/.test(t.lockAxis) && (this.options.drag.lockAxis = t.lockAxis), /^(xy|x|y)$/.test(t.startAxis) && (this.options.drag.startAxis = t.startAxis), this) : i.default.bool(t) ? (this.options.drag.enabled = t, this) : this.options.drag }, beforeMove: f, move: d, defaults: { startAxis: "xy", lockAxis: "xy" }, getCursor: function () { return "move" } }, v = p; c.default = v; var h = {}; Object.defineProperty(h, "__esModule", { value: !0 }), h.default = void 0; var g = { init: function (t) { var e = t; g.document = e.document, g.DocumentFragment = e.DocumentFragment || y, g.SVGElement = e.SVGElement || y, g.SVGSVGElement = e.SVGSVGElement || y, g.SVGElementInstance = e.SVGElementInstance || y, g.Element = e.Element || y, g.HTMLElement = e.HTMLElement || g.Element, g.Event = e.Event, g.Touch = e.Touch || y, g.PointerEvent = e.PointerEvent || e.MSPointerEvent }, document: null, DocumentFragment: null, SVGElement: null, SVGSVGElement: null, SVGElementInstance: null, Element: null, HTMLElement: null, Event: null, Touch: null, PointerEvent: null }; function y() { } var m = g; h.default = m; var b = {}; Object.defineProperty(b, "__esModule", { value: !0 }), b.default = void 0; var x = { init: function (t) { var e = h.default.Element, n = t.navigator || {}; x.supportsTouch = "ontouchstart" in t || i.default.func(t.DocumentTouch) && h.default.document instanceof t.DocumentTouch, x.supportsPointerEvent = !1 !== n.pointerEnabled && !!h.default.PointerEvent, x.isIOS = /iP(hone|od|ad)/.test(n.platform), x.isIOS7 = /iP(hone|od|ad)/.test(n.platform) && /OS 7[^\d]/.test(n.appVersion), x.isIe9 = /MSIE 9/.test(n.userAgent), x.isOperaMobile = "Opera" === n.appName && x.supportsTouch && /Presto/.test(n.userAgent), x.prefixedMatchesSelector = "matches" in e.prototype ? "matches" : "webkitMatchesSelector" in e.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in e.prototype ? "mozMatchesSelector" : "oMatchesSelector" in e.prototype ? "oMatchesSelector" : "msMatchesSelector", x.pEventTypes = x.supportsPointerEvent ? h.default.PointerEvent === t.MSPointerEvent ? { up: "MSPointerUp", down: "MSPointerDown", over: "mouseover", out: "mouseout", move: "MSPointerMove", cancel: "MSPointerCancel" } : { up: "pointerup", down: "pointerdown", over: "pointerover", out: "pointerout", move: "pointermove", cancel: "pointercancel" } : null, x.wheelEvent = h.default.document && "onmousewheel" in h.default.document ? "mousewheel" : "wheel" }, supportsTouch: null, supportsPointerEvent: null, isIOS7: null, isIOS: null, isIe9: null, isOperaMobile: null, prefixedMatchesSelector: null, pEventTypes: null, wheelEvent: null }, w = x; b.default = w; var _ = {}; function P(t) { var e = t.parentNode; if (i.default.docFrag(e)) { for (; (e = e.host) && i.default.docFrag(e);); return e } return e } function O(t, n) { return e.window !== e.realWindow && (n = n.replace(/\/deep\//g, " ")), t[b.default.prefixedMatchesSelector](n) } Object.defineProperty(_, "__esModule", { value: !0 }), _.closest = function (t, e) { for (; i.default.element(t);) { if (O(t, e)) return t; t = P(t) } return null }, _.getActualElement = function (t) { return t.correspondingUseElement || t }, _.getElementClientRect = j, _.getElementRect = function (t) { var n = j(t); if (!b.default.isIOS7 && n) { var r = T(e.getWindow(t)); n.left += r.x, n.right += r.x, n.top += r.y, n.bottom += r.y } return n }, _.getPath = function (t) { for (var e = []; t;)e.push(t), t = P(t); return e }, _.getScrollXY = T, _.indexOfDeepestElement = function (t) { for (var n, r = [], o = 0; o < t.length; o++) { var i = t[o], a = t[n]; if (i && o !== n) if (a) { var s = E(i), l = E(a); if (s !== i.ownerDocument) if (l !== i.ownerDocument) if (s !== l) { r = r.length ? r : S(a); var u = void 0; if (a instanceof h.default.HTMLElement && i instanceof h.default.SVGElement && !(i instanceof h.default.SVGSVGElement)) { if (i === l) continue; u = i.ownerSVGElement } else u = i; for (var c = S(u, a.ownerDocument), f = 0; c[f] && c[f] === r[f];)f++; var d = [c[f - 1], c[f], r[f]]; if (d[0]) for (var p = d[0].lastChild; p;) { if (p === d[1]) { n = o, r = c; break } if (p === d[2]) break; p = p.previousSibling } } else v = i, g = a, void 0, void 0, (parseInt(e.getWindow(v).getComputedStyle(v).zIndex, 10) || 0) >= (parseInt(e.getWindow(g).getComputedStyle(g).zIndex, 10) || 0) && (n = o); else n = o } else n = o } var v, g; return n }, _.matchesSelector = O, _.matchesUpTo = function (t, e, n) { for (; i.default.element(t);) { if (O(t, e)) return !0; if ((t = P(t)) === n) return O(t, e) } return !1 }, _.nodeContains = function (t, e) { if (t.contains) return t.contains(e); for (; e;) { if (e === t) return !0; e = e.parentNode } return !1 }, _.parentNode = P, _.trySelector = function (t) { return !!i.default.string(t) && (h.default.document.querySelector(t), !0) }; var E = function (t) { return t.parentNode || t.host }; function S(t, e) { for (var n, r = [], o = t; (n = E(o)) && o !== e && n !== o.ownerDocument;)r.unshift(o), o = n; return r } function T(t) { return { x: (t = t || e.window).scrollX || t.document.documentElement.scrollLeft, y: t.scrollY || t.document.documentElement.scrollTop } } function j(t) { var e = t instanceof h.default.SVGElement ? t.getBoundingClientRect() : t.getClientRects()[0]; return e && { left: e.left, right: e.right, top: e.top, bottom: e.bottom, width: e.width || e.right - e.left, height: e.height || e.bottom - e.top } } var M = {}; Object.defineProperty(M, "__esModule", { value: !0 }), M.default = function (t, e) { for (var n in e) t[n] = e[n]; return t }; var k = {}; function I(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } function D(t, e, n) { return "parent" === t ? (0, _.parentNode)(n) : "self" === t ? e.getRect(n) : (0, _.closest)(n, t) } Object.defineProperty(k, "__esModule", { value: !0 }), k.addEdges = function (t, e, n) { t.left && (e.left += n.x), t.right && (e.right += n.x), t.top && (e.top += n.y), t.bottom && (e.bottom += n.y), e.width = e.right - e.left, e.height = e.bottom - e.top }, k.getStringOptionResult = D, k.rectToXY = function (t) { return t && { x: "x" in t ? t.x : t.left, y: "y" in t ? t.y : t.top } }, k.resolveRectLike = function (t, e, n, r) { var o, a = t; return i.default.string(a) ? a = D(a, e, n) : i.default.func(a) && (a = a.apply(void 0, function (t) { if (Array.isArray(t)) return I(t) }(o = r) || function (t) { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t) }(o) || function (t, e) { if (t) { if ("string" == typeof t) return I(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? I(t, e) : void 0 } }(o) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }())), i.default.element(a) && (a = (0, _.getElementRect)(a)), a }, k.tlbrToXywh = function (t) { return !t || "x" in t && "y" in t || ((t = (0, M.default)({}, t)).x = t.left || 0, t.y = t.top || 0, t.width = t.width || (t.right || 0) - t.x, t.height = t.height || (t.bottom || 0) - t.y), t }, k.xywhToTlbr = function (t) { return !t || "left" in t && "top" in t || ((t = (0, M.default)({}, t)).left = t.x || 0, t.top = t.y || 0, t.right = t.right || t.left + t.width, t.bottom = t.bottom || t.top + t.height), t }; var A = {}; Object.defineProperty(A, "__esModule", { value: !0 }), A.default = function (t, e, n) { var r = t.options[n], o = r && r.origin || t.options.origin, i = (0, k.resolveRectLike)(o, t, e, [t && e]); return (0, k.rectToXY)(i) || { x: 0, y: 0 } }; var z = {}; function C(t) { return t.trim().split(/ +/) } Object.defineProperty(z, "__esModule", { value: !0 }), z.default = function t(e, n, r) { if (r = r || {}, i.default.string(e) && -1 !== e.search(" ") && (e = C(e)), i.default.array(e)) return e.reduce((function (e, o) { return (0, M.default)(e, t(o, n, r)) }), r); if (i.default.object(e) && (n = e, e = ""), i.default.func(n)) r[e] = r[e] || [], r[e].push(n); else if (i.default.array(n)) for (var o = 0; o < n.length; o++) { var a; a = n[o], t(e, a, r) } else if (i.default.object(n)) for (var s in n) { var l = C(s).map((function (t) { return "".concat(e).concat(t) })); t(l, n[s], r) } return r }; var R = {}; Object.defineProperty(R, "__esModule", { value: !0 }), R.default = void 0, R.default = function (t, e) { return Math.sqrt(t * t + e * e) }; var F = {}; Object.defineProperty(F, "__esModule", { value: !0 }), F.default = function (t, e) { t.__set || (t.__set = {}); var n = function (n) { if (X.some((function (t) { return 0 === n.indexOf(t) }))) return "continue"; "function" != typeof t[n] && "__set" !== n && Object.defineProperty(t, n, { get: function () { return n in t.__set ? t.__set[n] : t.__set[n] = e[n] }, set: function (e) { t.__set[n] = e }, configurable: !0 }) }; for (var r in e) n(r); return t }; var X = ["webkit", "moz"], B = {}; function Y(t) { return t instanceof h.default.Event || t instanceof h.default.Touch } function W(t, e, n) { return t = t || "page", (n = n || {}).x = e[t + "X"], n.y = e[t + "Y"], n } function L(t, e) { return e = e || { x: 0, y: 0 }, b.default.isOperaMobile && Y(t) ? (W("screen", t, e), e.x += window.scrollX, e.y += window.scrollY) : W("page", t, e), e } function U(t, e) { return e = e || {}, b.default.isOperaMobile && Y(t) ? W("screen", t, e) : W("client", t, e), e } function V(t) { var e = []; return i.default.array(t) ? (e[0] = t[0], e[1] = t[1]) : "touchend" === t.type ? 1 === t.touches.length ? (e[0] = t.touches[0], e[1] = t.changedTouches[0]) : 0 === t.touches.length && (e[0] = t.changedTouches[0], e[1] = t.changedTouches[1]) : (e[0] = t.touches[0], e[1] = t.touches[1]), e } function N(t) { for (var e = { pageX: 0, pageY: 0, clientX: 0, clientY: 0, screenX: 0, screenY: 0 }, n = 0; n < t.length; n++) { var r = t[n]; for (var o in e) e[o] += r[o] } for (var i in e) e[i] /= t.length; return e } Object.defineProperty(B, "__esModule", { value: !0 }), B.coordsToEvent = function (t) { return { coords: t, get page() { return this.coords.page }, get client() { return this.coords.client }, get timeStamp() { return this.coords.timeStamp }, get pageX() { return this.coords.page.x }, get pageY() { return this.coords.page.y }, get clientX() { return this.coords.client.x }, get clientY() { return this.coords.client.y }, get pointerId() { return this.coords.pointerId }, get target() { return this.coords.target }, get type() { return this.coords.type }, get pointerType() { return this.coords.pointerType }, get buttons() { return this.coords.buttons }, preventDefault: function () { } } }, B.copyCoords = function (t, e) { t.page = t.page || {}, t.page.x = e.page.x, t.page.y = e.page.y, t.client = t.client || {}, t.client.x = e.client.x, t.client.y = e.client.y, t.timeStamp = e.timeStamp }, B.getClientXY = U, B.getEventTargets = function (t) { var e = i.default.func(t.composedPath) ? t.composedPath() : t.path; return [_.getActualElement(e ? e[0] : t.target), _.getActualElement(t.currentTarget)] }, B.getPageXY = L, B.getPointerId = function (t) { return i.default.number(t.pointerId) ? t.pointerId : t.identifier }, B.getPointerType = function (t) { return i.default.string(t.pointerType) ? t.pointerType : i.default.number(t.pointerType) ? [void 0, void 0, "touch", "pen", "mouse"][t.pointerType] : /touch/.test(t.type || "") || t instanceof h.default.Touch ? "touch" : "mouse" }, B.getTouchPair = V, B.getXY = W, B.isNativePointer = Y, B.newCoords = function () { return { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 } }, B.pointerAverage = N, Object.defineProperty(B, "pointerExtend", { enumerable: !0, get: function () { return F.default } }), B.setCoordDeltas = function (t, e, n) { t.page.x = n.page.x - e.page.x, t.page.y = n.page.y - e.page.y, t.client.x = n.client.x - e.client.x, t.client.y = n.client.y - e.client.y, t.timeStamp = n.timeStamp - e.timeStamp }, B.setCoordVelocity = function (t, e) { var n = Math.max(e.timeStamp / 1e3, .001); t.page.x = e.page.x / n, t.page.y = e.page.y / n, t.client.x = e.client.x / n, t.client.y = e.client.y / n, t.timeStamp = n }, B.setCoords = function (t, e, n) { var r = e.length > 1 ? N(e) : e[0]; L(r, t.page), U(r, t.client), t.timeStamp = n }, B.setZeroCoords = function (t) { t.page.x = 0, t.page.y = 0, t.client.x = 0, t.client.y = 0 }, B.touchAngle = function (t, e) { var n = e + "X", r = e + "Y", o = V(t), i = o[1][n] - o[0][n], a = o[1][r] - o[0][r]; return 180 * Math.atan2(a, i) / Math.PI }, B.touchBBox = function (t) { if (!t.length) return null; var e = V(t), n = Math.min(e[0].pageX, e[1].pageX), r = Math.min(e[0].pageY, e[1].pageY), o = Math.max(e[0].pageX, e[1].pageX), i = Math.max(e[0].pageY, e[1].pageY); return { x: n, y: r, left: n, top: r, right: o, bottom: i, width: o - n, height: i - r } }, B.touchDistance = function (t, e) { var n = e + "X", r = e + "Y", o = V(t), i = o[0][n] - o[1][n], a = o[0][r] - o[1][r]; return (0, R.default)(i, a) }; var q = {}; function G(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function $(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } Object.defineProperty(q, "__esModule", { value: !0 }), q.BaseEvent = void 0; var H = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), $(this, "immediatePropagationStopped", !1), $(this, "propagationStopped", !1), this._interaction = e } var e, n; return e = t, (n = [{ key: "preventDefault", value: function () { } }, { key: "stopPropagation", value: function () { this.propagationStopped = !0 } }, { key: "stopImmediatePropagation", value: function () { this.immediatePropagationStopped = this.propagationStopped = !0 } }]) && G(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t }(); q.BaseEvent = H, Object.defineProperty(H.prototype, "interaction", { get: function () { return this._interaction._proxy }, set: function () { } }); var K = {}; Object.defineProperty(K, "__esModule", { value: !0 }), K.remove = K.merge = K.from = K.findIndex = K.find = K.contains = void 0, K.contains = function (t, e) { return -1 !== t.indexOf(e) }, K.remove = function (t, e) { return t.splice(t.indexOf(e), 1) }; var Z = function (t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; t.push(r) } return t }; K.merge = Z, K.from = function (t) { return Z([], t) }; var J = function (t, e) { for (var n = 0; n < t.length; n++)if (e(t[n], n, t)) return n; return -1 }; K.findIndex = J, K.find = function (t, e) { return t[J(t, e)] }; var Q = {}; function tt(t) { return tt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, tt(t) } function et(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function nt(t, e) { return nt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t }, nt(t, e) } function rt(t, e) { if (e && ("object" === tt(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return ot(t) } function ot(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function it(t) { return it = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t) }, it(t) } function at(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } Object.defineProperty(Q, "__esModule", { value: !0 }), Q.DropEvent = void 0; var st = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && nt(t, e) }(a, t); var e, n, r, o, i = (r = a, o = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(), function () { var t, e = it(r); if (o) { var n = it(this).constructor; t = Reflect.construct(e, arguments, n) } else t = e.apply(this, arguments); return rt(this, t) }); function a(t, e, n, r, o, s, l) { var u; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, a), at(ot(u = i.call(this, e._interaction)), "dropzone", void 0), at(ot(u), "dragEvent", void 0), at(ot(u), "relatedTarget", void 0), at(ot(u), "draggable", void 0), at(ot(u), "propagationStopped", !1), at(ot(u), "immediatePropagationStopped", !1); var o = "dragleave" === n ? t.prev : t.cur, s = o.element, l = o.dropzone; return u.type = n, u.target = s, u.currentTarget = s, u.dropzone = l, u.dragEvent = e, u.relatedTarget = e.target, u.draggable = e.interactable, u.timeStamp = e.timeStamp, u } return e = a, (n = [{ key: "reject", value: function () { var t = this, e = this._interaction.dropState; if ("dropactivate" === this.type || this.dropzone && e.cur.dropzone === this.dropzone && e.cur.element === this.target) if (e.prev.dropzone = this.dropzone, e.prev.element = this.target, e.rejected = !0, e.events.enter = null, this.stopImmediatePropagation(), "dropactivate" === this.type) { var n = e.activeDrops, r = K.findIndex(n, (function (e) { var n = e.dropzone, r = e.element; return n === t.dropzone && r === t.target })); e.activeDrops.splice(r, 1); var o = new a(e, this.dragEvent, "dropdeactivate"); o.dropzone = this.dropzone, o.target = this.target, this.dropzone.fire(o) } else this.dropzone.fire(new a(e, this.dragEvent, "dragleave")) } }, { key: "preventDefault", value: function () { } }, { key: "stopPropagation", value: function () { this.propagationStopped = !0 } }, { key: "stopImmediatePropagation", value: function () { this.immediatePropagationStopped = this.propagationStopped = !0 } }]) && et(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), a }(q.BaseEvent); Q.DropEvent = st; var lt = {}; function ut(t, e) { for (var n = 0; n < t.slice().length; n++) { var r = t.slice()[n], o = r.dropzone, i = r.element; e.dropzone = o, e.target = i, o.fire(e), e.propagationStopped = e.immediatePropagationStopped = !1 } } function ct(t, e) { for (var n = function (t, e) { for (var n = t.interactables, r = [], o = 0; o < n.list.length; o++) { var a = n.list[o]; if (a.options.drop.enabled) { var s = a.options.drop.accept; if (!(i.default.element(s) && s !== e || i.default.string(s) && !_.matchesSelector(e, s) || i.default.func(s) && !s({ dropzone: a, draggableElement: e }))) for (var l = i.default.string(a.target) ? a._context.querySelectorAll(a.target) : i.default.array(a.target) ? a.target : [a.target], u = 0; u < l.length; u++) { var c = l[u]; c !== e && r.push({ dropzone: a, element: c, rect: a.getRect(c) }) } } } return r }(t, e), r = 0; r < n.length; r++) { var o = n[r]; o.rect = o.dropzone.getRect(o.element) } return n } function ft(t, e, n) { for (var r = t.dropState, o = t.interactable, i = t.element, a = [], s = 0; s < r.activeDrops.length; s++) { var l = r.activeDrops[s], u = l.dropzone, c = l.element, f = l.rect; a.push(u.dropCheck(e, n, o, i, c, f) ? c : null) } var d = _.indexOfDeepestElement(a); return r.activeDrops[d] || null } function dt(t, e, n) { var r = t.dropState, o = { enter: null, leave: null, activate: null, deactivate: null, move: null, drop: null }; return "dragstart" === n.type && (o.activate = new Q.DropEvent(r, n, "dropactivate"), o.activate.target = null, o.activate.dropzone = null), "dragend" === n.type && (o.deactivate = new Q.DropEvent(r, n, "dropdeactivate"), o.deactivate.target = null, o.deactivate.dropzone = null), r.rejected || (r.cur.element !== r.prev.element && (r.prev.dropzone && (o.leave = new Q.DropEvent(r, n, "dragleave"), n.dragLeave = o.leave.target = r.prev.element, n.prevDropzone = o.leave.dropzone = r.prev.dropzone), r.cur.dropzone && (o.enter = new Q.DropEvent(r, n, "dragenter"), n.dragEnter = r.cur.element, n.dropzone = r.cur.dropzone)), "dragend" === n.type && r.cur.dropzone && (o.drop = new Q.DropEvent(r, n, "drop"), n.dropzone = r.cur.dropzone, n.relatedTarget = r.cur.element), "dragmove" === n.type && r.cur.dropzone && (o.move = new Q.DropEvent(r, n, "dropmove"), o.move.dragmove = n, n.dropzone = r.cur.dropzone)), o } function pt(t, e) { var n = t.dropState, r = n.activeDrops, o = n.cur, i = n.prev; e.leave && i.dropzone.fire(e.leave), e.enter && o.dropzone.fire(e.enter), e.move && o.dropzone.fire(e.move), e.drop && o.dropzone.fire(e.drop), e.deactivate && ut(r, e.deactivate), n.prev.dropzone = o.dropzone, n.prev.element = o.element } function vt(t, e) { var n = t.interaction, r = t.iEvent, o = t.event; if ("dragmove" === r.type || "dragend" === r.type) { var i = n.dropState; e.dynamicDrop && (i.activeDrops = ct(e, n.element)); var a = r, s = ft(n, a, o); i.rejected = i.rejected && !!s && s.dropzone === i.cur.dropzone && s.element === i.cur.element, i.cur.dropzone = s && s.dropzone, i.cur.element = s && s.element, i.events = dt(n, 0, a) } } Object.defineProperty(lt, "__esModule", { value: !0 }), lt.default = void 0; var ht = { id: "actions/drop", install: function (t) { var e = t.actions, n = t.interactStatic, r = t.Interactable, o = t.defaults; t.usePlugin(c.default), r.prototype.dropzone = function (t) { return function (t, e) { if (i.default.object(e)) { if (t.options.drop.enabled = !1 !== e.enabled, e.listeners) { var n = (0, z.default)(e.listeners), r = Object.keys(n).reduce((function (t, e) { return t[/^(enter|leave)/.test(e) ? "drag".concat(e) : /^(activate|deactivate|move)/.test(e) ? "drop".concat(e) : e] = n[e], t }), {}); t.off(t.options.drop.listeners), t.on(r), t.options.drop.listeners = r } return i.default.func(e.ondrop) && t.on("drop", e.ondrop), i.default.func(e.ondropactivate) && t.on("dropactivate", e.ondropactivate), i.default.func(e.ondropdeactivate) && t.on("dropdeactivate", e.ondropdeactivate), i.default.func(e.ondragenter) && t.on("dragenter", e.ondragenter), i.default.func(e.ondragleave) && t.on("dragleave", e.ondragleave), i.default.func(e.ondropmove) && t.on("dropmove", e.ondropmove), /^(pointer|center)$/.test(e.overlap) ? t.options.drop.overlap = e.overlap : i.default.number(e.overlap) && (t.options.drop.overlap = Math.max(Math.min(1, e.overlap), 0)), "accept" in e && (t.options.drop.accept = e.accept), "checker" in e && (t.options.drop.checker = e.checker), t } return i.default.bool(e) ? (t.options.drop.enabled = e, t) : t.options.drop }(this, t) }, r.prototype.dropCheck = function (t, e, n, r, o, a) { return function (t, e, n, r, o, a, s) { var l = !1; if (!(s = s || t.getRect(a))) return !!t.options.drop.checker && t.options.drop.checker(e, n, l, t, a, r, o); var u = t.options.drop.overlap; if ("pointer" === u) { var c = (0, A.default)(r, o, "drag"), f = B.getPageXY(e); f.x += c.x, f.y += c.y; var d = f.x > s.left && f.x < s.right, p = f.y > s.top && f.y < s.bottom; l = d && p } var v = r.getRect(o); if (v && "center" === u) { var h = v.left + v.width / 2, g = v.top + v.height / 2; l = h >= s.left && h <= s.right && g >= s.top && g <= s.bottom } return v && i.default.number(u) && (l = Math.max(0, Math.min(s.right, v.right) - Math.max(s.left, v.left)) * Math.max(0, Math.min(s.bottom, v.bottom) - Math.max(s.top, v.top)) / (v.width * v.height) >= u), t.options.drop.checker && (l = t.options.drop.checker(e, n, l, t, a, r, o)), l }(this, t, e, n, r, o, a) }, n.dynamicDrop = function (e) { return i.default.bool(e) ? (t.dynamicDrop = e, n) : t.dynamicDrop }, (0, M.default)(e.phaselessTypes, { dragenter: !0, dragleave: !0, dropactivate: !0, dropdeactivate: !0, dropmove: !0, drop: !0 }), e.methodDict.drop = "dropzone", t.dynamicDrop = !1, o.actions.drop = ht.defaults }, listeners: { "interactions:before-action-start": function (t) { var e = t.interaction; "drag" === e.prepared.name && (e.dropState = { cur: { dropzone: null, element: null }, prev: { dropzone: null, element: null }, rejected: null, events: null, activeDrops: [] }) }, "interactions:after-action-start": function (t, e) { var n = t.interaction, r = (t.event, t.iEvent); if ("drag" === n.prepared.name) { var o = n.dropState; o.activeDrops = null, o.events = null, o.activeDrops = ct(e, n.element), o.events = dt(n, 0, r), o.events.activate && (ut(o.activeDrops, o.events.activate), e.fire("actions/drop:start", { interaction: n, dragEvent: r })) } }, "interactions:action-move": vt, "interactions:after-action-move": function (t, e) { var n = t.interaction, r = t.iEvent; "drag" === n.prepared.name && (pt(n, n.dropState.events), e.fire("actions/drop:move", { interaction: n, dragEvent: r }), n.dropState.events = {}) }, "interactions:action-end": function (t, e) { if ("drag" === t.interaction.prepared.name) { var n = t.interaction, r = t.iEvent; vt(t, e), pt(n, n.dropState.events), e.fire("actions/drop:end", { interaction: n, dragEvent: r }) } }, "interactions:stop": function (t) { var e = t.interaction; if ("drag" === e.prepared.name) { var n = e.dropState; n && (n.activeDrops = null, n.events = null, n.cur.dropzone = null, n.cur.element = null, n.prev.dropzone = null, n.prev.element = null, n.rejected = !1) } } }, getActiveDrops: ct, getDrop: ft, getDropEvents: dt, fireDropEvents: pt, defaults: { enabled: !1, accept: null, overlap: "pointer" } }, gt = ht; lt.default = gt; var yt = {}; function mt(t) { var e = t.interaction, n = t.iEvent, r = t.phase; if ("gesture" === e.prepared.name) { var o = e.pointers.map((function (t) { return t.pointer })), a = "start" === r, s = "end" === r, l = e.interactable.options.deltaSource; if (n.touches = [o[0], o[1]], a) n.distance = B.touchDistance(o, l), n.box = B.touchBBox(o), n.scale = 1, n.ds = 0, n.angle = B.touchAngle(o, l), n.da = 0, e.gesture.startDistance = n.distance, e.gesture.startAngle = n.angle; else if (s) { var u = e.prevEvent; n.distance = u.distance, n.box = u.box, n.scale = u.scale, n.ds = 0, n.angle = u.angle, n.da = 0 } else n.distance = B.touchDistance(o, l), n.box = B.touchBBox(o), n.scale = n.distance / e.gesture.startDistance, n.angle = B.touchAngle(o, l), n.ds = n.scale - e.gesture.scale, n.da = n.angle - e.gesture.angle; e.gesture.distance = n.distance, e.gesture.angle = n.angle, i.default.number(n.scale) && n.scale !== 1 / 0 && !isNaN(n.scale) && (e.gesture.scale = n.scale) } } Object.defineProperty(yt, "__esModule", { value: !0 }), yt.default = void 0; var bt = { id: "actions/gesture", before: ["actions/drag", "actions/resize"], install: function (t) { var e = t.actions, n = t.Interactable, r = t.defaults; n.prototype.gesturable = function (t) { return i.default.object(t) ? (this.options.gesture.enabled = !1 !== t.enabled, this.setPerAction("gesture", t), this.setOnEvents("gesture", t), this) : i.default.bool(t) ? (this.options.gesture.enabled = t, this) : this.options.gesture }, e.map.gesture = bt, e.methodDict.gesture = "gesturable", r.actions.gesture = bt.defaults }, listeners: { "interactions:action-start": mt, "interactions:action-move": mt, "interactions:action-end": mt, "interactions:new": function (t) { t.interaction.gesture = { angle: 0, distance: 0, scale: 1, startAngle: 0, startDistance: 0 } }, "auto-start:check": function (t) { if (!(t.interaction.pointers.length < 2)) { var e = t.interactable.options.gesture; if (e && e.enabled) return t.action = { name: "gesture" }, !1 } } }, defaults: {}, getCursor: function () { return "" } }, xt = bt; yt.default = xt; var wt = {}; function _t(t, e, n, r, o, a, s) { if (!e) return !1; if (!0 === e) { var l = i.default.number(a.width) ? a.width : a.right - a.left, u = i.default.number(a.height) ? a.height : a.bottom - a.top; if (s = Math.min(s, Math.abs(("left" === t || "right" === t ? l : u) / 2)), l < 0 && ("left" === t ? t = "right" : "right" === t && (t = "left")), u < 0 && ("top" === t ? t = "bottom" : "bottom" === t && (t = "top")), "left" === t) { var c = l >= 0 ? a.left : a.right; return n.x < c + s } if ("top" === t) { var f = u >= 0 ? a.top : a.bottom; return n.y < f + s } if ("right" === t) return n.x > (l >= 0 ? a.right : a.left) - s; if ("bottom" === t) return n.y > (u >= 0 ? a.bottom : a.top) - s } return !!i.default.element(r) && (i.default.element(e) ? e === r : _.matchesUpTo(r, e, o)) } function Pt(t) { var e = t.iEvent, n = t.interaction; if ("resize" === n.prepared.name && n.resizeAxes) { var r = e; n.interactable.options.resize.square ? ("y" === n.resizeAxes ? r.delta.x = r.delta.y : r.delta.y = r.delta.x, r.axes = "xy") : (r.axes = n.resizeAxes, "x" === n.resizeAxes ? r.delta.y = 0 : "y" === n.resizeAxes && (r.delta.x = 0)) } } Object.defineProperty(wt, "__esModule", { value: !0 }), wt.default = void 0; var Ot = { id: "actions/resize", before: ["actions/drag"], install: function (t) { var e = t.actions, n = t.browser, r = t.Interactable, o = t.defaults; Ot.cursors = function (t) { return t.isIe9 ? { x: "e-resize", y: "s-resize", xy: "se-resize", top: "n-resize", left: "w-resize", bottom: "s-resize", right: "e-resize", topleft: "se-resize", bottomright: "se-resize", topright: "ne-resize", bottomleft: "ne-resize" } : { x: "ew-resize", y: "ns-resize", xy: "nwse-resize", top: "ns-resize", left: "ew-resize", bottom: "ns-resize", right: "ew-resize", topleft: "nwse-resize", bottomright: "nwse-resize", topright: "nesw-resize", bottomleft: "nesw-resize" } }(n), Ot.defaultMargin = n.supportsTouch || n.supportsPointerEvent ? 20 : 10, r.prototype.resizable = function (e) { return function (t, e, n) { return i.default.object(e) ? (t.options.resize.enabled = !1 !== e.enabled, t.setPerAction("resize", e), t.setOnEvents("resize", e), i.default.string(e.axis) && /^x$|^y$|^xy$/.test(e.axis) ? t.options.resize.axis = e.axis : null === e.axis && (t.options.resize.axis = n.defaults.actions.resize.axis), i.default.bool(e.preserveAspectRatio) ? t.options.resize.preserveAspectRatio = e.preserveAspectRatio : i.default.bool(e.square) && (t.options.resize.square = e.square), t) : i.default.bool(e) ? (t.options.resize.enabled = e, t) : t.options.resize }(this, e, t) }, e.map.resize = Ot, e.methodDict.resize = "resizable", o.actions.resize = Ot.defaults }, listeners: { "interactions:new": function (t) { t.interaction.resizeAxes = "xy" }, "interactions:action-start": function (t) { !function (t) { var e = t.iEvent, n = t.interaction; if ("resize" === n.prepared.name && n.prepared.edges) { var r = e, o = n.rect; n._rects = { start: (0, M.default)({}, o), corrected: (0, M.default)({}, o), previous: (0, M.default)({}, o), delta: { left: 0, right: 0, width: 0, top: 0, bottom: 0, height: 0 } }, r.edges = n.prepared.edges, r.rect = n._rects.corrected, r.deltaRect = n._rects.delta } }(t), Pt(t) }, "interactions:action-move": function (t) { !function (t) { var e = t.iEvent, n = t.interaction; if ("resize" === n.prepared.name && n.prepared.edges) { var r = e, o = n.interactable.options.resize.invert, i = "reposition" === o || "negate" === o, a = n.rect, s = n._rects, l = s.start, u = s.corrected, c = s.delta, f = s.previous; if ((0, M.default)(f, u), i) { if ((0, M.default)(u, a), "reposition" === o) { if (u.top > u.bottom) { var d = u.top; u.top = u.bottom, u.bottom = d } if (u.left > u.right) { var p = u.left; u.left = u.right, u.right = p } } } else u.top = Math.min(a.top, l.bottom), u.bottom = Math.max(a.bottom, l.top), u.left = Math.min(a.left, l.right), u.right = Math.max(a.right, l.left); for (var v in u.width = u.right - u.left, u.height = u.bottom - u.top, u) c[v] = u[v] - f[v]; r.edges = n.prepared.edges, r.rect = u, r.deltaRect = c } }(t), Pt(t) }, "interactions:action-end": function (t) { var e = t.iEvent, n = t.interaction; if ("resize" === n.prepared.name && n.prepared.edges) { var r = e; r.edges = n.prepared.edges, r.rect = n._rects.corrected, r.deltaRect = n._rects.delta } }, "auto-start:check": function (t) { var e = t.interaction, n = t.interactable, r = t.element, o = t.rect, a = t.buttons; if (o) { var s = (0, M.default)({}, e.coords.cur.page), l = n.options.resize; if (l && l.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (a & l.mouseButtons))) { if (i.default.object(l.edges)) { var u = { left: !1, right: !1, top: !1, bottom: !1 }; for (var c in u) u[c] = _t(c, l.edges[c], s, e._latestPointer.eventTarget, r, o, l.margin || Ot.defaultMargin); u.left = u.left && !u.right, u.top = u.top && !u.bottom, (u.left || u.right || u.top || u.bottom) && (t.action = { name: "resize", edges: u }) } else { var f = "y" !== l.axis && s.x > o.right - Ot.defaultMargin, d = "x" !== l.axis && s.y > o.bottom - Ot.defaultMargin; (f || d) && (t.action = { name: "resize", axes: (f ? "x" : "") + (d ? "y" : "") }) } return !t.action && void 0 } } } }, defaults: { square: !1, preserveAspectRatio: !1, axis: "xy", margin: NaN, edges: null, invert: "none" }, cursors: null, getCursor: function (t) { var e = t.edges, n = t.axis, r = t.name, o = Ot.cursors, i = null; if (n) i = o[r + n]; else if (e) { for (var a = "", s = ["top", "bottom", "left", "right"], l = 0; l < s.length; l++) { var u = s[l]; e[u] && (a += u) } i = o[a] } return i }, defaultMargin: null }, Et = Ot; wt.default = Et; var St = {}; Object.defineProperty(St, "__esModule", { value: !0 }), St.default = void 0; var Tt = { id: "actions", install: function (t) { t.usePlugin(yt.default), t.usePlugin(wt.default), t.usePlugin(c.default), t.usePlugin(lt.default) } }; St.default = Tt; var jt = {}; Object.defineProperty(jt, "__esModule", { value: !0 }), jt.default = void 0; var Mt, kt, It = 0, Dt = { request: function (t) { return Mt(t) }, cancel: function (t) { return kt(t) }, init: function (t) { if (Mt = t.requestAnimationFrame, kt = t.cancelAnimationFrame, !Mt) for (var e = ["ms", "moz", "webkit", "o"], n = 0; n < e.length; n++) { var r = e[n]; Mt = t["".concat(r, "RequestAnimationFrame")], kt = t["".concat(r, "CancelAnimationFrame")] || t["".concat(r, "CancelRequestAnimationFrame")] } Mt = Mt && Mt.bind(t), kt = kt && kt.bind(t), Mt || (Mt = function (e) { var n = Date.now(), r = Math.max(0, 16 - (n - It)), o = t.setTimeout((function () { e(n + r) }), r); return It = n + r, o }, kt = function (t) { return clearTimeout(t) }) } }; jt.default = Dt; var At = {}; Object.defineProperty(At, "__esModule", { value: !0 }), At.default = void 0, At.getContainer = Ct, At.getScroll = Rt, At.getScrollSize = function (t) { return i.default.window(t) && (t = window.document.body), { x: t.scrollWidth, y: t.scrollHeight } }, At.getScrollSizeDelta = function (t, e) { var n = t.interaction, r = t.element, o = n && n.interactable.options[n.prepared.name].autoScroll; if (!o || !o.enabled) return e(), { x: 0, y: 0 }; var i = Ct(o.container, n.interactable, r), a = Rt(i); e(); var s = Rt(i); return { x: s.x - a.x, y: s.y - a.y } }; var zt = { defaults: { enabled: !1, margin: 60, container: null, speed: 300 }, now: Date.now, interaction: null, i: 0, x: 0, y: 0, isScrolling: !1, prevTime: 0, margin: 0, speed: 0, start: function (t) { zt.isScrolling = !0, jt.default.cancel(zt.i), t.autoScroll = zt, zt.interaction = t, zt.prevTime = zt.now(), zt.i = jt.default.request(zt.scroll) }, stop: function () { zt.isScrolling = !1, zt.interaction && (zt.interaction.autoScroll = null), jt.default.cancel(zt.i) }, scroll: function () { var t = zt.interaction, e = t.interactable, n = t.element, r = t.prepared.name, o = e.options[r].autoScroll, a = Ct(o.container, e, n), s = zt.now(), l = (s - zt.prevTime) / 1e3, u = o.speed * l; if (u >= 1) { var c = { x: zt.x * u, y: zt.y * u }; if (c.x || c.y) { var f = Rt(a); i.default.window(a) ? a.scrollBy(c.x, c.y) : a && (a.scrollLeft += c.x, a.scrollTop += c.y); var d = Rt(a), p = { x: d.x - f.x, y: d.y - f.y }; (p.x || p.y) && e.fire({ type: "autoscroll", target: n, interactable: e, delta: p, interaction: t, container: a }) } zt.prevTime = s } zt.isScrolling && (jt.default.cancel(zt.i), zt.i = jt.default.request(zt.scroll)) }, check: function (t, e) { var n; return null == (n = t.options[e].autoScroll) ? void 0 : n.enabled }, onInteractionMove: function (t) { var e = t.interaction, n = t.pointer; if (e.interacting() && zt.check(e.interactable, e.prepared.name)) if (e.simulation) zt.x = zt.y = 0; else { var r, o, i, a, s, l = e.interactable, u = e.element, c = e.prepared.name, f = l.options[c].autoScroll, d = Ct(f.container, l, u); if (i.default.window(d)) s = n.clientX < zt.margin, r = n.clientY < zt.margin, o = n.clientX > d.innerWidth - zt.margin, a = n.clientY > d.innerHeight - zt.margin; else { var p = _.getElementClientRect(d); s = n.clientX < p.left + zt.margin, r = n.clientY < p.top + zt.margin, o = n.clientX > p.right - zt.margin, a = n.clientY > p.bottom - zt.margin } zt.x = o ? 1 : s ? -1 : 0, zt.y = a ? 1 : r ? -1 : 0, zt.isScrolling || (zt.margin = f.margin, zt.speed = f.speed, zt.start(e)) } } }; function Ct(t, n, r) { return (i.default.string(t) ? (0, k.getStringOptionResult)(t, n, r) : t) || (0, e.getWindow)(r) } function Rt(t) { return i.default.window(t) && (t = window.document.body), { x: t.scrollLeft, y: t.scrollTop } } var Ft = { id: "auto-scroll", install: function (t) { var e = t.defaults, n = t.actions; t.autoScroll = zt, zt.now = function () { return t.now() }, n.phaselessTypes.autoscroll = !0, e.perAction.autoScroll = zt.defaults }, listeners: { "interactions:new": function (t) { t.interaction.autoScroll = null }, "interactions:destroy": function (t) { t.interaction.autoScroll = null, zt.stop(), zt.interaction && (zt.interaction = null) }, "interactions:stop": zt.stop, "interactions:action-move": function (t) { return zt.onInteractionMove(t) } } }, Xt = Ft; At.default = Xt; var Bt = {}; Object.defineProperty(Bt, "__esModule", { value: !0 }), Bt.copyAction = function (t, e) { return t.name = e.name, t.axis = e.axis, t.edges = e.edges, t }, Bt.sign = void 0, Bt.warnOnce = function (t, n) { var r = !1; return function () { return r || (e.window.console.warn(n), r = !0), t.apply(this, arguments) } }, Bt.sign = function (t) { return t >= 0 ? 1 : -1 }; var Yt = {}; function Wt(t) { return i.default.bool(t) ? (this.options.styleCursor = t, this) : null === t ? (delete this.options.styleCursor, this) : this.options.styleCursor } function Lt(t) { return i.default.func(t) ? (this.options.actionChecker = t, this) : null === t ? (delete this.options.actionChecker, this) : this.options.actionChecker } Object.defineProperty(Yt, "__esModule", { value: !0 }), Yt.default = void 0; var Ut = { id: "auto-start/interactableMethods", install: function (t) { var e = t.Interactable; e.prototype.getAction = function (e, n, r, o) { var i = function (t, e, n, r, o) { var i = t.getRect(r), a = { action: null, interactable: t, interaction: n, element: r, rect: i, buttons: e.buttons || { 0: 1, 1: 4, 3: 8, 4: 16 }[e.button] }; return o.fire("auto-start:check", a), a.action }(this, n, r, o, t); return this.options.actionChecker ? this.options.actionChecker(e, n, i, this, o, r) : i }, e.prototype.ignoreFrom = (0, Bt.warnOnce)((function (t) { return this._backCompatOption("ignoreFrom", t) }), "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."), e.prototype.allowFrom = (0, Bt.warnOnce)((function (t) { return this._backCompatOption("allowFrom", t) }), "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."), e.prototype.actionChecker = Lt, e.prototype.styleCursor = Wt } }; Yt.default = Ut; var Vt = {}; function Nt(t, e, n, r, o) { return e.testIgnoreAllow(e.options[t.name], n, r) && e.options[t.name].enabled && Ht(e, n, t, o) ? t : null } function qt(t, e, n, r, o, i, a) { for (var s = 0, l = r.length; s < l; s++) { var u = r[s], c = o[s], f = u.getAction(e, n, t, c); if (f) { var d = Nt(f, u, c, i, a); if (d) return { action: d, interactable: u, element: c } } } return { action: null, interactable: null, element: null } } function Gt(t, e, n, r, o) { var a = [], s = [], l = r; function u(t) { a.push(t), s.push(l) } for (; i.default.element(l);) { a = [], s = [], o.interactables.forEachMatch(l, u); var c = qt(t, e, n, a, s, r, o); if (c.action && !c.interactable.options[c.action.name].manualStart) return c; l = _.parentNode(l) } return { action: null, interactable: null, element: null } } function $t(t, e, n) { var r = e.action, o = e.interactable, i = e.element; r = r || { name: null }, t.interactable = o, t.element = i, (0, Bt.copyAction)(t.prepared, r), t.rect = o && r.name ? o.getRect(i) : null, Jt(t, n), n.fire("autoStart:prepared", { interaction: t }) } function Ht(t, e, n, r) { var o = t.options, i = o[n.name].max, a = o[n.name].maxPerElement, s = r.autoStart.maxInteractions, l = 0, u = 0, c = 0; if (!(i && a && s)) return !1; for (var f = 0; f < r.interactions.list.length; f++) { var d = r.interactions.list[f], p = d.prepared.name; if (d.interacting()) { if (++l >= s) return !1; if (d.interactable === t) { if ((u += p === n.name ? 1 : 0) >= i) return !1; if (d.element === e && (c++, p === n.name && c >= a)) return !1 } } } return s > 0 } function Kt(t, e) { return i.default.number(t) ? (e.autoStart.maxInteractions = t, this) : e.autoStart.maxInteractions } function Zt(t, e, n) { var r = n.autoStart.cursorElement; r && r !== t && (r.style.cursor = ""), t.ownerDocument.documentElement.style.cursor = e, t.style.cursor = e, n.autoStart.cursorElement = e ? t : null } function Jt(t, e) { var n = t.interactable, r = t.element, o = t.prepared; if ("mouse" === t.pointerType && n && n.options.styleCursor) { var i = ""; if (o.name) { var a = n.options[o.name].cursorChecker; i = i.default.func(a) ? a(o, n, r, t._interacting) : e.actions.map[o.name].getCursor(o) } Zt(t.element, i || "", e) } else e.autoStart.cursorElement && Zt(e.autoStart.cursorElement, "", e) } Object.defineProperty(Vt, "__esModule", { value: !0 }), Vt.default = void 0; var Qt = { id: "auto-start/base", before: ["actions"], install: function (t) { var e = t.interactStatic, n = t.defaults; t.usePlugin(Yt.default), n.base.actionChecker = null, n.base.styleCursor = !0, (0, M.default)(n.perAction, { manualStart: !1, max: 1 / 0, maxPerElement: 1, allowFrom: null, ignoreFrom: null, mouseButtons: 1 }), e.maxInteractions = function (e) { return Kt(e, t) }, t.autoStart = { maxInteractions: 1 / 0, withinInteractionLimit: Ht, cursorElement: null } }, listeners: { "interactions:down": function (t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget; n.interacting() || $t(n, Gt(n, r, o, i, e), e) }, "interactions:move": function (t, e) { !function (t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget; "mouse" !== n.pointerType || n.pointerIsDown || n.interacting() || $t(n, Gt(n, r, o, i, e), e) }(t, e), function (t, e) { var n = t.interaction; if (n.pointerIsDown && !n.interacting() && n.pointerWasMoved && n.prepared.name) { e.fire("autoStart:before-start", t); var r = n.interactable, o = n.prepared.name; o && r && (r.options[o].manualStart || !Ht(r, n.element, n.prepared, e) ? n.stop() : (n.start(n.prepared, r, n.element), Jt(n, e))) } }(t, e) }, "interactions:stop": function (t, e) { var n = t.interaction, r = n.interactable; r && r.options.styleCursor && Zt(n.element, "", e) } }, maxInteractions: Kt, withinInteractionLimit: Ht, validateAction: Nt }, te = Qt; Vt.default = te; var ee = {}; Object.defineProperty(ee, "__esModule", { value: !0 }), ee.default = void 0; var ne = { id: "auto-start/dragAxis", listeners: { "autoStart:before-start": function (t, e) { var n = t.interaction, r = t.eventTarget, o = t.dx, a = t.dy; if ("drag" === n.prepared.name) { var s = Math.abs(o), l = Math.abs(a), u = n.interactable.options.drag, c = u.startAxis, f = s > l ? "x" : s < l ? "y" : "xy"; if (n.prepared.axis = "start" === u.lockAxis ? f[0] : u.lockAxis, "xy" !== f && "xy" !== c && c !== f) { n.prepared.name = null; for (var d = r, p = function (t) { if (t !== n.interactable) { var o = n.interactable.options.drag; if (!o.manualStart && t.testIgnoreAllow(o, d, r)) { var i = t.getAction(n.downPointer, n.downEvent, n, d); if (i && "drag" === i.name && function (t, e) { if (!e) return !1; var n = e.options.drag.startAxis; return "xy" === t || "xy" === n || n === t }(f, t) && Vt.default.validateAction(i, t, d, r, e)) return t } } }; i.default.element(d);) { var v = e.interactables.forEachMatch(d, p); if (v) { n.prepared.name = "drag", n.interactable = v, n.element = d; break } d = (0, _.parentNode)(d) } } } } } }; ee.default = ne; var re = {}; function oe(t) { var e = t.prepared && t.prepared.name; if (!e) return null; var n = t.interactable.options; return n[e].hold || n[e].delay } Object.defineProperty(re, "__esModule", { value: !0 }), re.default = void 0; var ie = { id: "auto-start/hold", install: function (t) { var e = t.defaults; t.usePlugin(Vt.default), e.perAction.hold = 0, e.perAction.delay = 0 }, listeners: { "interactions:new": function (t) { t.interaction.autoStartHoldTimer = null }, "autoStart:prepared": function (t) { var e = t.interaction, n = oe(e); n > 0 && (e.autoStartHoldTimer = setTimeout((function () { e.start(e.prepared, e.interactable, e.element) }), n)) }, "interactions:move": function (t) { var e = t.interaction, n = t.duplicate; e.autoStartHoldTimer && e.pointerWasMoved && !n && (clearTimeout(e.autoStartHoldTimer), e.autoStartHoldTimer = null) }, "autoStart:before-start": function (t) { var e = t.interaction; oe(e) > 0 && (e.prepared.name = null) } }, getHoldDuration: oe }, ae = ie; re.default = ae; var se = {}; Object.defineProperty(se, "__esModule", { value: !0 }), se.default = void 0; var le = { id: "auto-start", install: function (t) { t.usePlugin(Vt.default), t.usePlugin(re.default), t.usePlugin(ee.default) } }; se.default = le; var ue = {}; function ce(t) { return /^(always|never|auto)$/.test(t) ? (this.options.preventDefault = t, this) : i.default.bool(t) ? (this.options.preventDefault = t ? "always" : "never", this) : this.options.preventDefault } function fe(t) { var e = t.interaction, n = t.event; e.interactable && e.interactable.checkAndPreventDefault(n) } function de(t) { var n = t.Interactable; n.prototype.preventDefault = ce, n.prototype.checkAndPreventDefault = function (n) { return function (t, n, r) { var o = t.options.preventDefault; if ("never" !== o) if ("always" !== o) { if (n.events.supportsPassive && /^touch(start|move)$/.test(r.type)) { var a = (0, e.getWindow)(r.target).document, s = n.getDocOptions(a); if (!s || !s.events || !1 !== s.events.passive) return } /^(mouse|pointer|touch)*(down|start)/i.test(r.type) || i.default.element(r.target) && (0, _.matchesSelector)(r.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *") || r.preventDefault() } else r.preventDefault() }(this, t, n) }, t.interactions.docEvents.push({ type: "dragstart", listener: function (e) { for (var n = 0; n < t.interactions.list.length; n++) { var r = t.interactions.list[n]; if (r.element && (r.element === e.target || (0, _.nodeContains)(r.element, e.target))) return void r.interactable.checkAndPreventDefault(e) } } }) } Object.defineProperty(ue, "__esModule", { value: !0 }), ue.default = void 0, ue.install = de; var pe = { id: "core/interactablePreventDefault", install: de, listeners: ["down", "move", "up", "cancel"].reduce((function (t, e) { return t["interactions:".concat(e)] = fe, t }), {}) }; ue.default = pe; var ve = {}; Object.defineProperty(ve, "__esModule", { value: !0 }), ve.default = void 0, ve.default = {}; var he, ge = {}; Object.defineProperty(ge, "__esModule", { value: !0 }), ge.default = void 0, function (t) { t.touchAction = "touchAction", t.boxSizing = "boxSizing", t.noListeners = "noListeners" }(he || (he = {})); he.touchAction, he.boxSizing, he.noListeners; var ye = { id: "dev-tools", install: function () { } }; ge.default = ye; var me = {}; Object.defineProperty(me, "__esModule", { value: !0 }), me.default = function t(e) { var n = {}; for (var r in e) { var o = e[r]; i.default.plainObject(o) ? n[r] = t(o) : i.default.array(o) ? n[r] = K.from(o) : n[r] = o } return n }; var be = {}; function xe(t, e) { return function (t) { if (Array.isArray(t)) return t }(t) || function (t, e) { var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (null != n) { var r, o, i = [], a = !0, s = !1; try { for (n = n.call(t); !(a = (r = n.next()).done) && (i.push(r.value), !e || i.length !== e); a = !0); } catch (t) { s = !0, o = t } finally { try { a || null == n.return || n.return() } finally { if (s) throw o } } return i } }(t, e) || function (t, e) { if (t) { if ("string" == typeof t) return I(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? I(t, e) : void 0 } }(t, e) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function we(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } function _e(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function Pe(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } Object.defineProperty(be, "__esModule", { value: !0 }), be.default = void 0, be.getRectOffset = Se; var Oe = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), Pe(this, "states", []), Pe(this, "startOffset", { left: 0, right: 0, top: 0, bottom: 0 }), Pe(this, "startDelta", void 0), Pe(this, "result", void 0), Pe(this, "endResult", void 0), Pe(this, "startEdges", void 0), Pe(this, "edges", void 0), Pe(this, "interaction", void 0), this.interaction = e, this.result = Ee(), this.edges = { left: !1, right: !1, top: !1, bottom: !1 } } var e, n; return e = t, (n = [{ key: "start", value: function (t, e) { var n = t.phase, r = this.interaction, o = function (t) { var e = t.interactable.options[t.prepared.name], n = e.modifiers; return n && n.length ? n : ["snap", "snapSize", "snapEdges", "restrict", "restrictEdges", "restrictSize"].map((function (t) { var n = e[t]; return n && n.enabled && { options: n, methods: n._methods } })).filter((function (t) { return !!t })) }(r); this.prepareStates(o), this.startEdges = (0, M.default)({}, r.edges), this.edges = (0, M.default)({}, this.startEdges), this.startOffset = Se(r.rect, e), this.startDelta = { x: 0, y: 0 }; var i = this.fillArg({ phase: n, pageCoords: e, preEnd: !1 }); return this.result = Ee(), this.startAll(i), this.result = this.setAll(i) } }, { key: "fillArg", value: function (t) { var e = this.interaction; return t.interaction = e, t.interactable = e.interactable, t.element = e.element, t.rect || (t.rect = e.rect), t.edges || (t.edges = this.startEdges), t.startOffset = this.startOffset, t } }, { key: "startAll", value: function (t) { for (var e = 0; e < this.states.length; e++) { var n = this.states[e]; n.methods.start && (t.state = n, n.methods.start(t)) } } }, { key: "setAll", value: function (t) { var e = t.phase, n = t.preEnd, r = t.skipModifiers, o = t.rect, i = t.edges; t.coords = (0, M.default)({}, t.pageCoords), t.rect = (0, M.default)({}, o), t.edges = (0, M.default)({}, i); for (var a = n ? this.states.slice(n) : this.states, s = Ee(t.coords, t.rect), l = 0; l < a.length; l++) { var u, c = a[l], f = c.options, d = (0, M.default)({}, t.coords), p = null; null != (u = c.methods) && u.set && this.shouldDo(f, n, e) && (t.state = c, p = c.methods.set(t), k.addEdges(t.edges, t.rect, { x: t.coords.x - d.x, y: t.coords.y - d.y })), s.eventProps.push(p) } (0, M.default)(this.edges, t.edges), s.delta.x = t.coords.x - t.pageCoords.x, s.delta.y = t.coords.y - t.pageCoords.y, s.rectDelta.left = t.rect.left - o.left, s.rectDelta.right = t.rect.right - o.right, s.rectDelta.top = t.rect.top - o.top, s.rectDelta.bottom = t.rect.bottom - o.bottom; var v = this.result.coords, h = this.result.rect; if (v && h) { var g = s.rect.left !== h.left || s.rect.right !== h.right || s.rect.top !== h.top || s.rect.bottom !== h.bottom; s.changed = g || v.x !== s.coords.x || v.y !== s.coords.y } return s } }, { key: "applyToInteraction", value: function (t) { var e = this.interaction, n = t.phase, r = e.coords.cur, o = e.coords.start, i = this.result, a = this.startDelta, s = i.delta; "start" === n && (0, M.default)(this.startDelta, i.delta); for (var l = 0; l < [[o, a], [r, s]].length; l++) { var u = xe([[o, a], [r, s]][l], 2), c = u[0], f = u[1]; c.page.x += f.x, c.page.y += f.y, c.client.x += f.x, c.client.y += f.y } var d = this.result.rectDelta, p = t.rect || e.rect; p.left += d.left, p.right += d.right, p.top += d.top, p.bottom += d.bottom, p.width = p.right - p.left, p.height = p.bottom - p.top } }, { key: "setAndApply", value: function (t) { var e = this.interaction, n = t.phase, r = t.preEnd, o = t.skipModifiers, i = this.setAll(this.fillArg({ preEnd: r, phase: n, pageCoords: t.modifiedCoords || e.coords.cur.page })); if (this.result = i, !i.changed && (!o || o < this.states.length) && e.interacting()) return !1; if (t.modifiedCoords) { var a = e.coords.cur.page, s = { x: t.modifiedCoords.x - a.x, y: t.modifiedCoords.y - a.y }; i.coords.x += s.x, i.coords.y += s.y, i.delta.x += s.x, i.delta.y += s.y } this.applyToInteraction(t) } }, { key: "beforeEnd", value: function (t) { var e = t.interaction, n = t.event, r = this.states; if (r && r.length) { for (var o = !1, i = 0; i < r.length; i++) { var a = r[i]; t.state = a; var s = a.options, l = a.methods, u = l.beforeEnd && l.beforeEnd(t); if (u) return this.endResult = u, !1; o = o || !o && this.shouldDo(s, !0, t.phase, !0) } o && e.move({ event: n, preEnd: !0 }) } } }, { key: "stop", value: function (t) { var e = t.interaction; if (this.states && this.states.length) { var n = (0, M.default)({ states: this.states, interactable: e.interactable, element: e.element, rect: null }, t); this.fillArg(n); for (var r = 0; r < this.states.length; r++) { var o = this.states[r]; n.state = o, o.methods.stop && o.methods.stop(n) } this.states = null, this.endResult = null } } }, { key: "prepareStates", value: function (t) { this.states = []; for (var e = 0; e < t.length; e++) { var n = t[e], r = n.options, o = n.methods, i = n.name; this.states.push({ options: r, methods: o, index: e, name: i }) } return this.states } }, { key: "restoreInteractionCoords", value: function (t) { var e = t.interaction, n = e.coords, r = e.rect, o = e.modification; if (o.result) { for (var i = o.startDelta, a = o.result, s = a.delta, l = a.rectDelta, u = [[n.start, i], [n.cur, s]], c = 0; c < u.length; c++) { var f = xe(u[c], 2), d = f[0], p = f[1]; d.page.x -= p.x, d.page.y -= p.y, d.client.x -= p.x, d.client.y -= p.y } var v = this.result.rectDelta, h = t.rect || e.rect; h.left += v.left, h.right += v.right, h.top += v.top, h.bottom += v.bottom } } }, { key: "shouldDo", value: function (t, e, n, r) { return !(!t || !1 === t.enabled || r && !t.endOnly || t.endOnly && !e || "start" === n && !t.setStart) } }, { key: "copyFrom", value: function (t) { this.startOffset = t.startOffset, this.startDelta = t.startDelta, this.startEdges = t.startEdges, this.edges = t.edges, this.states = t.states.map((function (t) { return (0, me.default)(t) })), this.result = Ee((0, M.default)({}, t.result.coords), (0, M.default)({}, t.result.rect)) } }, { key: "destroy", value: function () { for (var t in this) this[t] = null } }]) && _e(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t }(); function Ee(t, e) { return { rect: e, coords: t, delta: { x: 0, y: 0 }, rectDelta: { left: 0, right: 0, top: 0, bottom: 0 }, eventProps: [], changed: !0 } } function Se(t, e) { return t ? { left: e.x - t.left, top: e.y - t.top, right: t.right - e.x, bottom: t.bottom - e.y } : { left: 0, top: 0, right: 0, bottom: 0 } } be.default = Oe; var Te = {}; function je(t) { var e = t.iEvent, n = t.interaction.modification.result; n && (e.modifiers = n.eventProps) } Object.defineProperty(Te, "__esModule", { value: !0 }), Te.addEventModifiers = je, Te.default = void 0, Te.makeModifier = function (t, e) { var n = t.defaults, r = { start: t.start, set: t.set, beforeEnd: t.beforeEnd, stop: t.stop }, o = function (t) { var o = t || {}; for (var i in o.enabled = !1 !== o.enabled, n) i in o || (o[i] = n[i]); var a = { options: o, methods: r, name: e, enable: function () { return o.enabled = !0, a }, disable: function () { return o.enabled = !1, a } }; return a }; return e && "string" == typeof e && (o._defaults = n, o._methods = r), o }; var Me = { id: "modifiers/base", before: ["actions"], install: function (t) { t.defaults.perAction.modifiers = [] }, listeners: { "interactions:new": function (t) { var e = t.interaction; e.modification = new be.default(e) }, "interactions:before-action-start": function (t) { var e = t.interaction, n = t.interaction.modification; n.start(t, e.coords.start.page), e.edges = n.edges, n.applyToInteraction(t) }, "interactions:before-action-move": function (t) { var e = t.interaction, n = e.modification, r = n.setAndApply(t); return e.edges = n.edges, r }, "interactions:before-action-end": function (t) { var e = t.interaction, n = e.modification, r = n.beforeEnd(t); return e.edges = n.startEdges, r }, "interactions:action-start": je, "interactions:action-move": je, "interactions:action-end": je, "interactions:after-action-start": function (t) { return t.interaction.modification.restoreInteractionCoords(t) }, "interactions:after-action-move": function (t) { return t.interaction.modification.restoreInteractionCoords(t) }, "interactions:stop": function (t) { return t.interaction.modification.stop(t) } } }, ke = Me; Te.default = ke; var Ie = {}; Object.defineProperty(Ie, "__esModule", { value: !0 }), Ie.defaults = void 0, Ie.defaults = { base: { preventDefault: "auto", deltaSource: "page" }, perAction: { enabled: !1, origin: { x: 0, y: 0 } }, actions: {} }; var De = {}; function Ae(t) { return Ae = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, Ae(t) } function ze(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function Ce(t, e) { return Ce = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t }, Ce(t, e) } function Re(t, e) { if (e && ("object" === Ae(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) } function Fe(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Xe(t) { return Xe = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t) }, Xe(t) } function Be(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } Object.defineProperty(De, "__esModule", { value: !0 }), De.InteractEvent = void 0; var Ye = function (t) { !function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && Ce(t, e) }(a, t); var e, n, r, o, i = (r = a, o = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } }(), function () { var t, e = Xe(r); if (o) { var n = Xe(this).constructor; t = Reflect.construct(e, arguments, n) } else t = e.apply(this, arguments); return Re(this, t) }); function a(t, e, n, r, o, s, l) { var u; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, a), Be(Fe(u = i.call(this, t)), "relatedTarget", null), Be(Fe(u), "screenX", void 0), Be(Fe(u), "screenY", void 0), Be(Fe(u), "button", void 0), Be(Fe(u), "buttons", void 0), Be(Fe(u), "ctrlKey", void 0), Be(Fe(u), "shiftKey", void 0), Be(Fe(u), "altKey", void 0), Be(Fe(u), "metaKey", void 0), Be(Fe(u), "page", void 0), Be(Fe(u), "client", void 0), Be(Fe(u), "delta", void 0), Be(Fe(u), "rect", void 0), Be(Fe(u), "x0", void 0), Be(Fe(u), "y0", void 0), Be(Fe(u), "t0", void 0), Be(Fe(u), "dt", void 0), Be(Fe(u), "duration", void 0), Be(Fe(u), "clientX0", void 0), Be(Fe(u), "clientY0", void 0), Be(Fe(u), "velocity", void 0), Be(Fe(u), "speed", void 0), Be(Fe(u), "swipe", void 0), Be(Fe(u), "axes", void 0), Be(Fe(u), "preEnd", void 0), o = o || t.element; var c = t.interactable, f = (c && c.options || Ie.defaults).deltaSource, d = (0, A.default)(c, o, n), p = "start" === r, v = "end" === r, h = p ? Fe(u) : t.prevEvent, g = p ? t.coords.start : v ? { page: h.page, client: h.client, timeStamp: t.coords.cur.timeStamp } : t.coords.cur; return u.page = (0, M.default)({}, g.page), u.client = (0, M.default)({}, g.client), u.rect = (0, M.default)({}, t.rect), u.timeStamp = g.timeStamp, v || (u.page.x -= d.x, u.page.y -= d.y, u.client.x -= d.x, u.client.y -= d.y), u.ctrlKey = e.ctrlKey, u.altKey = e.altKey, u.shiftKey = e.shiftKey, u.metaKey = e.metaKey, u.button = e.button, u.buttons = e.buttons, u.target = r, u.currentTarget = r, u.preEnd = s, u.type = l || n + (r || ""), u.interactable = c, u.t0 = p ? t.pointers[t.pointers.length - 1].downTime : h.t0, u.x0 = t.coords.start.page.x - d.x, u.y0 = t.coords.start.page.y - d.y, u.clientX0 = t.coords.start.client.x - d.x, u.clientY0 = t.coords.start.client.y - d.x, u.delta = p || v ? { x: 0, y: 0 } : { x: u[f].x - h[f].x, y: u[f].y - h[f].y }, u.dt = t.coords.delta.timeStamp, u.duration = u.timeStamp - u.t0, u.velocity = (0, M.default)({}, t.coords.velocity[f]), u.speed = (0, R.default)(u.velocity.x, u.velocity.y), u.swipe = v || "inertiastart" === r ? u.getSwipe() : null, u } return e = a, (n = [{ key: "getSwipe", value: function () { var t = this._interaction; if (t.prevEvent.speed < 600 || this.timeStamp - t.prevEvent.timeStamp > 150) return null; var e = 180 * Math.atan2(t.prevEvent.velocityY, t.prevEvent.velocityX) / Math.PI; e < 0 && (e += 360); var n = 112.5 <= e && e < 247.5, r = 202.5 <= e && e < 337.5; return { up: r, down: !r && 22.5 <= e && e < 157.5, left: n, right: !n && (292.5 <= e || e < 67.5), angle: e, speed: t.prevEvent.speed, velocity: { x: t.prevEvent.velocityX, y: t.prevEvent.velocityY } } } }, { key: "preventDefault", value: function () { } }, { key: "stopImmediatePropagation", value: function () { this.immediatePropagationStopped = this.propagationStopped = !0 } }, { key: "stopPropagation", value: function () { this.propagationStopped = !0 } }]) && ze(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), a }(q.BaseEvent); Mo.PointerEvent = Mo.default = Ro; var Fo = {}; Object.defineProperty(Fo, "__esModule", { value: !0 }), Fo.default = void 0; var Xo = { id: "pointer-events/base", before: ["inertia", "modifiers", "auto-start", "actions"], install: function (t) { t.pointerEvents = Xo, t.defaults.actions.pointerEvents = Xo.defaults, (0, M.default)(t.actions.phaselessTypes, Xo.types) }, listeners: { "interactions:new": function (t) { var e = t.interaction; e.prevTap = null, e.tapTime = 0 }, "interactions:update-pointer": function (t) { var e = t.down, n = t.pointerInfo; !e && n.hold || (n.hold = { duration: 1 / 0, timeout: null }) }, "interactions:move": function (t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget; t.duplicate || n.pointerIsDown && !n.pointerWasMoved || (n.pointerIsDown && Wo(t), Bo({ interaction: n, pointer: r, event: o, eventTarget: i, type: "move" }, e)) }, "interactions:down": function (t, e) { !function (t, e) { for (var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget, a = t.pointerIndex, s = n.pointers[a].hold, l = _.getPath(i), u = { interaction: n, pointer: r, event: o, eventTarget: i, type: "hold", targets: [], path: l, node: null }, c = 0; c < l.length; c++) { var f = l[c]; u.node = f, e.fire("pointerEvents:collect-targets", u) } if (u.targets.length) { for (var d = 1 / 0, p = 0; p < u.targets.length; p++) { var v = u.targets[p].eventable.options.holdDuration; v < d && (d = v) } s.duration = d, s.timeout = setTimeout((function () { return Bo({ interaction: n, eventTarget: i, pointer: r, event: o, type: "hold" }, e) }), d) } }(t, e), Bo(t, e) }, "interactions:up": function (t, e) { Wo(t), Bo(t, e), function (t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget; n.pointerWasMoved || Bo({ interaction: n, eventTarget: i, pointer: r, event: o, type: "tap" }, e) }(t, e) }, "interactions:cancel": function (t, e) { Wo(t), Bo(t, e) } }, PointerEvent: Mo.PointerEvent, fire: Bo, collectEventTargets: Yo, defaults: { holdDuration: 600, ignoreFrom: null, allowFrom: null, origin: { x: 0, y: 0 } }, types: { down: !0, move: !0, up: !0, cancel: !0, tap: !0, doubletap: !0, hold: !0 } }; function Bo(t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget, a = t.type, s = t.targets, l = void 0 === s ? Yo(t, e) : s, u = new Mo.PointerEvent(a, r, o, i, n, e.now()); e.fire("pointerEvents:new", { pointerEvent: u }); for (var c = { interaction: n, pointer: r, event: o, eventTarget: i, targets: l, type: a, pointerEvent: u }, f = 0; f < l.length; f++) { var d = l[f]; for (var p in d.props || {}) u[p] = d.props[p]; var v = (0, A.default)(d.eventable, d.node); if (u._subtractOrigin(v), u.eventable = d.eventable, u.currentTarget = d.node, d.eventable.fire(u), u._addOrigin(v), u.immediatePropagationStopped || u.propagationStopped && f + 1 < l.length && l[f + 1].node !== u.currentTarget) break } if (e.fire("pointerEvents:fired", c), "tap" === a) { var h = u.double ? Bo({ interaction: n, pointer: r, event: o, eventTarget: i, type: "doubletap" }, e) : u; n.prevTap = h, n.tapTime = h.timeStamp } return u } function Yo(t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget, a = t.type, s = n.getPointerIndex(r), l = n.pointers[s]; if ("tap" === a && (n.pointerWasMoved || !l || l.downTarget !== i)) return []; for (var u = _.getPath(i), c = { interaction: n, pointer: r, event: o, eventTarget: i, type: a, path: u, targets: [], node: null }, f = 0; f < u.length; f++) { var d = u[f]; c.node = d, e.fire("pointerEvents:collect-targets", c) } return "hold" === a && (c.targets = c.targets.filter((function (t) { var e; return t.eventable.options.holdDuration === (null == (e = n.pointers[s]) ? void 0 : e.hold.duration) }))), c.targets } function Wo(t) { var e = t.interaction, n = t.pointerIndex, r = e.pointers[n].hold; r && r.timeout && (clearTimeout(r.timeout), r.timeout = null) } var Lo = Xo; Fo.default = Lo; var Uo = {}; function Vo(t) { var e = t.interaction; e.holdIntervalHandle && (clearInterval(e.holdIntervalHandle), e.holdIntervalHandle = null) } Object.defineProperty(Uo, "__esModule", { value: !0 }), Uo.default = void 0; var No = { id: "pointer-events/holdRepeat", install: function (t) { t.usePlugin(Fo.default); var e = t.pointerEvents; e.defaults.holdRepeatInterval = 0, e.types.holdrepeat = t.actions.phaselessTypes.holdrepeat = !0 }, listeners: ["move", "up", "cancel", "endall"].reduce((function (t, e) { return t["pointerEvents:".concat(e)] = Vo, t }), { "pointerEvents:new": function (t) { var e = t.pointerEvent; "hold" === e.type && (e.count = (e.count || 0) + 1) }, "pointerEvents:fired": function (t, e) { var n = t.interaction, r = t.pointerEvent, o = t.eventTarget, i = t.targets; if ("hold" === r.type && i.length) { var a = i[0].eventable.options.holdRepeatInterval; a <= 0 || (n.holdIntervalHandle = setTimeout((function () { return Bo({ interaction: n, eventTarget: o, pointer: r, event: r }, e) }), a)) } } }) }, qo = No; Uo.default = qo; var Go = {}; function $o(t) { return (0, M.default)(this.events.options, t), this } Object.defineProperty(Go, "__esModule", { value: !0 }), Go.default = void 0; var Ho = { id: "pointer-events/interactableTargets", install: function (t) { var e = t.Interactable; e.prototype.pointerEvents = $o; var n = e.prototype._backCompatOption; e.prototype._backCompatOption = function (t, e) { var r = n.call(this, t, e); return r === this && (this.events.options[t] = e), r } }, listeners: { "pointerEvents:collect-targets": function (t, e) { var n = t.targets, r = t.node, o = t.type, i = t.eventTarget; e.interactables.forEachMatch(r, (function (t) { var e = t.events, a = e.options; e.types[o] && e.types[o].length && t.testIgnoreAllow(a, r, i) && n.push({ node: r, eventable: e, props: { interactable: t } }) })) }, "interactable:new": function (t) { var e = t.interactable; e.events.getRect = function (t) { return e.getRect(t) } }, "interactable:set": function (t, e) { var n = t.interactable, r = t.options; (0, M.default)(n.events.options, e.pointerEvents.defaults), (0, M.default)(n.events.options, r.pointerEvents || {}) } } }, Ko = Ho; Go.default = Ko; var Zo = {}; Object.defineProperty(Zo, "__esModule", { value: !0 }), Zo.default = void 0; var Jo = { id: "pointer-events", install: function (t) { t.usePlugin(Fo), t.usePlugin(Uo.default), t.usePlugin(Go.default) } }, Qo = Jo; Zo.default = Qo; var ti = {}; function ei(t) { var e = t.Interactable; t.actions.phases.reflow = !0, e.prototype.reflow = function (e) { return function (t, e, n) { for (var r = i.default.string(t.target) ? K.from(t._context.querySelectorAll(t.target)) : [t.target], o = n.window.Promise, a = o ? [] : null, s = function () { var i = r[l], s = t.getRect(i); if (!s) return "break"; var u = K.find(n.interactions.list, (function (n) { return n.interacting() && n.interactable === t && n.element === i && n.prepared.name === e.name })), c = void 0; if (u) u.move(), a && (c = u._reflowPromise || new o((function (t) { u._reflowResolve = t }))); else { var f = (0, k.tlbrToXywh)(s), d = { page: { x: f.x, y: f.y }, client: { x: f.x, y: f.y }, timeStamp: n.now() }, p = B.coordsToEvent(d); c = function (t, e, n, r, o) { var i = t.interactions.new({ pointerType: "reflow" }), a = { interaction: i, event: o, pointer: o, eventTarget: n, phase: "reflow" }; i.interactable = e, i.element = n, i.prevEvent = o, i.updatePointer(o, o, n, !0), B.setZeroCoords(i.coords.delta), (0, Bt.copyAction)(i.prepared, r), i._doPhase(a); var s = t.window.Promise, l = s ? new s((function (t) { i._reflowResolve = t })) : void 0; return i._reflowPromise = l, i.start(r, e, n), i._interacting ? (i.move(a), i.end(o)) : (i.stop(), i._reflowResolve()), i.removePointer(o, o), l }(n, t, i, e, p) } a && a.push(c) }, l = 0; l < r.length && "break" !== s(); l++); return a && o.all(a).then((function () { return t })) }(this, e, t) } } Object.defineProperty(ti, "__esModule", { value: !0 }), ti.default = void 0, ti.install = ei; var ni = { id: "reflow", install: ei, listeners: { "interactions:stop": function (t, e) { var n = t.interaction; "reflow" === n.pointerType && (n._reflowResolve && n._reflowResolve(), K.remove(e.interactions.list, n)) } } }, ri = ni; ti.default = ri; var oi = {}; Object.defineProperty(oi, "__esModule", { value: !0 }), oi.default = void 0, xr.default.use(ue.default), xr.default.use(tn.default), xr.default.use(Zo.default), xr.default.use(un.default), xr.default.use(So.default), xr.default.use(se.default), xr.default.use(St.default), xr.default.use(At.default), xr.default.use(ti.default); var ii = xr.default; oi.default = ii, xr.default.default = xr.default, St.default, At.default, se.default, ue.default, ge.default, un.default, xr.default, So.default, tn.default, Zo.default, ti.default; var ai = { exports: {} }; function si(t) { return si = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, si(t) } Object.defineProperty(ai.exports, "__esModule", { value: !0 }), ai.exports.default = void 0; var li = oi.default; if (ai.exports.default = li, "object" === si(ai) && ai) try { ai.exports = oi.default } catch (t) { } return oi.default.default = oi.default, ai.exports }));
//# sourceMappingURL=interact.min.js.map